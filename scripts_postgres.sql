create schema aulas;

set search_path to aulas;

create schema data_science;
set search_path to data_science;

create table departamentos(
    departamento varchar(100),
    divisao varchar(100),
    primary key (departamento)
);

insert into departamentos values ('Automotivo','Auto & Hardware');
insert into departamentos values ('Bebês','Casa e Afins');
insert into departamentos values ('Beleza','Casa e Afins');
insert into departamentos values ('Roupas','Casa e Afins');
insert into departamentos values ('Computadores','Equipamentos Eletrônicos');
insert into departamentos values ('Eletronicos','Equipamentos Eletrônicos');
insert into departamentos values ('Games','Casa e Afins');
insert into departamentos values ('Jardim','Outdoors & Jardim');
insert into departamentos values ('Alimentícios','Casa e Afins');
insert into departamentos values ('Saúde','Casa e Afins');
insert into departamentos values ('Lar','Casa e Afins');
insert into departamentos values ('Industrial','Auto & Hardware');
insert into departamentos values ('Joalheria','Fashion');
insert into departamentos values ('Crianças','Casa e Afins');
insert into departamentos values ('Filmes','Entretenimento');
insert into departamentos values ('Música','Entretenimento');
insert into departamentos values ('Outdoors','Outdoors & Jardim');
insert into departamentos values ('Calçados','Casa e Afins');
insert into departamentos values ('Esporte','Games & Esporte');
insert into departamentos values ('Ferramentas','Auto & Hardware');
insert into departamentos values ('Brinquedos','Games & Esporte');

create table localizacao (
   idRegiao int,
   localizacao varchar(20),
   pais varchar(20),
   primary key (idRegiao)
  );

insert into localizacao values (1, 'Nordeste', 'Brasil');
insert into localizacao values (2, 'Sudeste', 'Brasil');
insert into localizacao values (3, 'Sul', 'Brasil');
insert into localizacao values (4, 'Norte', 'Brasil');
insert into localizacao values (5, 'British Columbia', 'Canada');
insert into localizacao values (6, 'Quebec', 'Canada');
insert into localizacao values (7, 'Nova Scotia', 'Canada');

create table funcionarios
  (
      idFuncionario integer,
      nome varchar(100),
      email varchar(200),
      sexo varchar(10),
      departamento varchar(100),
      admissao date,
      salario integer,
      cargo varchar(100),
      idRegiao int,
      primary key (idFuncionario)
  );


show datestyle;
-- mostra o estilo de data usado no banco de dados

/* FUNÇÕES DE AGREGAÇÃO
  COUNT(), MAX(), MIN(), SUM(), AVG()
*/

/* Query simples */
SELECT * FROM FUNCIONARIOS;

/* Contando o numero de ocorrencias */
SELECT COUNT(*) AS NUM_FUNCIONARIOS FROM FUNCIONARIOS;
SELECT COUNT(*) AS NUM_DEPARTAMENTOS FROM DEPARTAMENTOS;
SELECT COUNT(*) AS NUM_LOCALIZACOES FROM LOCALIZACAO;

/* Agrupando os funcionarios por sexo */
SELECT SEXO, COUNT(*) AS QUANTIDADE
FROM FUNCIONARIOS
GROUP BY SEXO;

/* Mostrando o número de funcionários de cada departamento, ordenando no maior para o menor */
SELECT DEPARTAMENTO, COUNT(*) AS QUANTIDADE_FUNCIONARIOS
FROM FUNCIONARIOS
GROUP BY DEPARTAMENTO
ORDER BY QUANTIDADE_FUNCIONARIOS DESC;

/* Agrupando os departamentos por divisao */
SELECT DIVISAO, COUNT(*) AS QUANTIDADE
FROM DEPARTAMENTOS
GROUP BY DIVISAO;

/* Exibindo os maior dos salários */
SELECT MAX(SALARIO) AS MAIOR_SALARIO FROM FUNCIONARIOS;

/* Exibindo os menor dos salários */
SELECT MIN(SALARIO) AS MAIOR_SALARIO FROM FUNCIONARIOS;

/* Exibindo o maior e o menor salario juntos */
SELECT MAX(SALARIO) AS MAIOR_SALARIO, MIN(SALARIO) AS MENOR_SALARIO FROM FUNCIONARIOS;

/* Exibindo dados do funcionario de maior salario */
SELECT NOME, SEXO, DEPARTAMENTO, SALARIO, CARGO
FROM FUNCIONARIOS
WHERE SALARIO = 149929;

/* Exibindo dados do funcionario de menor salario */
SELECT NOME, SEXO, DEPARTAMENTO, SALARIO, CARGO
FROM FUNCIONARIOS
WHERE SALARIO = 40138;

/* Exibindo o máximo e o mínimo de cada departamento */
SELECT DEPARTAMENTO, MIN(SALARIO) MAIOR_SALARIO, MAX(SALARIO) MENOR_SALARIO
FROM FUNCIONARIOS
GROUP BY DEPARTAMENTO;

/* Exibindo o máximo e o mínimo por sexo */
SELECT SEXO, MAX(SALARIO) MAIOR_SALARIO, MIN(SALARIO) MENOR_SALARIO
FROM FUNCIONARIOS
GROUP BY SEXO;

-- ANÁLISE ESTATÍSTICA
/* Mostrando um número limitado de linhas */
SELECT * FROM FUNCIONARIOS
LIMIT 10;

/* Gasto total de salário pago pela empresa */
SELECT SUM(SALARIO) AS SOMA_DE_SALARIOS FROM FUNCIONARIOS;

/* Montante total pago para cada departamento */
SELECT DEPARTAMENTO, SUM(SALARIO) AS SOMA_SALARIO
FROM FUNCIONARIOS
GROUP BY DEPARTAMENTO
ORDER BY SOMA_SALARIO DESC;

/* Qual o total e a média pagos por departamento para os funcionarios? */
SELECT DEPARTAMENTO, SUM(SALARIO) AS TOTAL, AVG(SALARIO) AS MEDIA
FROM FUNCIONARIOS
GROUP BY DEPARTAMENTO
ORDER BY MEDIA DESC;

/* Modelagem Banco de Dados x Data Science
    Banco de dados: 1ª, 2ª e 3ª formas normais
    Evitam redundancia, consequentemente poupam
    espaço em disco. Consomem muito processamento
    em função de joins.

   Data science e BI: focam em agregações e performance.
   Não se preocupam com espaço em disco. Em BI temos
   uma modelagem minima (DW), em DS temos preferencialmente
   uma modelagem em forma de colunas.
*/

-- Importando CSV

/* Antes de fazer a imporetação tenho que criar a
   tabela que receberá esses dados
 */
CREATE TABLE MAQUINA (
    MAQUINA VARCHAR(20),
    DIA INT,
    QTD NUMERIC(10,2)
);


-- Importando de fato o arquivo
COPY MAQUINA
FROM '/Users/luishenriquebelisario/Projetos/curso_sql/modulo_postgres/LogMaquinas.csv'
DELIMITER ','
CSV HEADER;

SELECT * FROM MAQUINA;

-- Media por Maquina
SELECT M.MAQUINA, ROUND(AVG(QTD), 2) AS MEDIA
FROM MAQUINA AS M
GROUP BY M.MAQUINA
ORDER BY MEDIA DESC;

-- Moda das quantidades
SELECT M.MAQUINA, M.QTD, COUNT(*) AS NUM_MAQUINAS
FROM MAQUINA AS M
GROUP BY M.MAQUINA, M.QTD
ORDER BY NUM_MAQUINAS DESC;

-- QUAL A MODA DAS QUANTIDADES DE CADA MAQUINA?
SELECT M.MAQUINA, M.QTD, COUNT(*) AS NUM_MAQUINAS
FROM MAQUINA AS M
WHERE M.MAQUINA = 'Maquina 01'
GROUP BY M.MAQUINA, M.QTD
ORDER BY NUM_MAQUINAS DESC
LIMIT 1;

SELECT M.MAQUINA, M.QTD, COUNT(*) AS NUM_MAQUINAS
FROM MAQUINA AS M
WHERE M.MAQUINA = 'Maquina 02'
GROUP BY M.MAQUINA, M.QTD
ORDER BY NUM_MAQUINAS DESC
LIMIT 1;

SELECT M.MAQUINA, M.QTD, COUNT(*) AS NUM_MAQUINAS
FROM MAQUINA AS M
WHERE M.MAQUINA = 'Maquina 03'
GROUP BY M.MAQUINA, M.QTD
ORDER BY NUM_MAQUINAS DESC
LIMIT 1;

-- Moda do dataset inteiro
SELECT QTD, COUNT(*) AS MODA
FROM MAQUINA
GROUP BY QTD
ORDER BY 2 DESC;


-- Amplitude de um set de dados
SELECT MAQUINA,
       MAX(QTD) AS MAXIMO,
       MIN(QTD) AS MINIMO,
       MAX(QTD) - MIN(QTD) AS AMPLITUDE
FROM MAQUINA
GROUP BY MAQUINA
ORDER BY AMPLITUDE DESC;

-- Acrescentando a media
SELECT MAQUINA,
       MAX(QTD) AS MAXIMO,
       MIN(QTD) AS MINIMO,
       MAX(QTD) - MIN(QTD) AS AMPLITUDE,
       AVG(QTD) AS MEDIA
FROM MAQUINA
GROUP BY MAQUINA
ORDER BY AMPLITUDE DESC;

-- Desvio padrão e variancia
SELECT MAQUINA,
       MAX(QTD) AS MAXIMO,
       MIN(QTD) AS MINIMO,
       MAX(QTD) - MIN(QTD) AS AMPLITUDE,
       AVG(QTD) AS MEDIA,
       ROUND(STDDEV_POP(QTD), 1) AS DESVIO_PADRAO,
       ROUND(VAR_POP(QTD), 1) AS VARIANCIA,
FROM MAQUINA
GROUP BY MAQUINA
ORDER BY MAQUINA;

-- Mediana
/*
 Para a mediana devemos criar uma procedure,
 pois no postgres não há uma função especifica
 para ela
*/
CREATE OR REPLACE FUNCTION _final_median(NUMERIC[])
   RETURNS NUMERIC AS
$$
   SELECT AVG(val)
   FROM (
     SELECT val
     FROM unnest($1) val
     ORDER BY 1
     LIMIT  2 - MOD(array_upper($1, 1), 2)
     OFFSET CEIL(array_upper($1, 1) / 2.0) - 1
   ) sub;
$$
LANGUAGE 'sql' IMMUTABLE;


CREATE AGGREGATE median(NUMERIC) (
  SFUNC=array_append,
  STYPE=NUMERIC[],
  FINALFUNC=_final_median,
  INITCOND='{}'
);

-- Mediana da maquina 01
SELECT MEDIAN(QTD) AS MEDIANA
FROM MAQUINA AS M
WHERE M.MAQUINA='Maquina 01';

-- Mediana da maquina 02
SELECT MEDIAN(QTD) AS MEDIANA
FROM MAQUINA AS M
WHERE M.MAQUINA='Maquina 02';

-- Mediana da maquina 03
SELECT MEDIAN(QTD) AS MEDIANA
FROM MAQUINA AS M
WHERE M.MAQUINA='Maquina 03';

INSERT INTO MAQUINA VALUES('Maquina 01',11,15.9);
INSERT INTO MAQUINA VALUES('Maquina 02',11,15.4);
INSERT INTO MAQUINA VALUES('Maquina 03',11,15.7);
INSERT INTO MAQUINA VALUES('Maquina 01',12,30);
INSERT INTO MAQUINA VALUES('Maquina 02',12,24);
INSERT INTO MAQUINA VALUES('Maquina 03',12,45);

SELECT MEDIAN(QTD) AS MEDIANA
FROM MAQUINA AS M
WHERE M.MAQUINA='Maquina 01';

SELECT MEDIAN(QTD) AS MEDIANA
FROM MAQUINA AS M
WHERE M.MAQUINA='Maquina 02';

SELECT MEDIAN(QTD) AS MEDIANA
FROM MAQUINA AS M
WHERE M.MAQUINA='Maquina 03';

/*
    RELATORIO ESTATISTICO COMPLETO COM:
    QUANTIDADE DE MAQUINAS
    VALOR TOTAL DE GRAOS PARA CADA MAQUINA
    MEDIA
    MODA
    MEDIANA
    MAXIMO
    MINIMO
    AMPLITUDE TOTAL (MAX-MIN) OBS.: AMPLITUDE INTERQUARTIL (1Q - 3Q)
    VARIANCIA
    DESVIO PADRAO
    COEF DE VAR
*/

SELECT M.MAQUINA,
       COUNT(QTD) AS QUANTIDADE_MAQUINAS,
       SUM(QTD) AS QUANTIDADE_GRAOS,
       ROUND(AVG(QTD), 1) AS MEDIA,
       MODE() WITHIN GROUP ( ORDER BY QTD ) AS MODA,
       ROUND(MEDIAN(QTD), 1) AS MEDIANA,
       MAX(QTD) AS VALOR_MAXIMO,
       MIN(QTD) AS VALOR_MINIMO,
       MAX(QTD) - MIN(QTD) AS AMPLITUDE,
       ROUND(VAR_POP(QTD), 1) AS VARIANCIA,
       ROUND(STDDEV_POP(QTD), 1)  AS DESVIO_PADRAO,
       ROUND((STDDEV_POP(QTD)/AVG(QTD))*100, 1) AS COEF_VARIACAO
FROM MAQUINA AS M
GROUP BY M.MAQUINA
ORDER BY M.MAQUINA;

/* MODA */
SELECT MODE() WITHIN GROUP ( ORDER BY QTD ) AS MODA FROM MAQUINA;


/* COMO EXPORTAR DE UM FORMATO DE BANCO DE DADOS
   PARA UM FORMATO COLUNAR (DATA SCIENCE)
 */
CREATE SCHEMA LOCADORA;

SET SEARCH_PATH TO LOCADORA;

CREATE TABLE GENERO(
	IDGENERO INT PRIMARY KEY,
	NOME VARCHAR(30)
);

INSERT INTO GENERO VALUES(1,'FANTASIA');
INSERT INTO GENERO VALUES(2,'AVENTURA');
INSERT INTO GENERO VALUES(3,'SUSPENSE');
INSERT INTO GENERO VALUES(4,'AÇÃO');
INSERT INTO GENERO VALUES(5,'DRAMA');

CREATE TABLE FILME(
	IDFILME INT PRIMARY KEY,
	NOME VARCHAR(50),
	ANO INT,
    ID_GENERO INT,
	FOREIGN KEY(ID_GENERO)
	REFERENCES GENERO(IDGENERO)
);

INSERT INTO FILME VALUES(100,'KILL BILL I',2007,2);
INSERT INTO FILME VALUES(200,'DRACULA',1998,3);
INSERT INTO FILME VALUES(300,'SENHOR DOS ANEIS',2008,1);
INSERT INTO FILME VALUES(400,'UM SONHO DE LIBERDADE',2008,5);
INSERT INTO FILME VALUES(500,'OS BAD BOYS',2008,4);
INSERT INTO FILME VALUES(600,'GUERRA CIVIL',2016,2);
INSERT INTO FILME VALUES(700,'CADILLAC RECORDS',2009,5);
INSERT INTO FILME VALUES(800,'O HOBBIT',2008,1);
INSERT INTO FILME VALUES(900,'TOMATES VERDES FRITOS',2008,5);
INSERT INTO FILME VALUES(1000,'CORRIDA MORTAL',2008,4);

CREATE TABLE LOCACAO(
	IDLOCACAO INT PRIMARY KEY,
	DATA DATE,
	MIDIA INT,
	DIAS INT,
	ID_FILME INT,
	FOREIGN KEY(ID_FILME)
	REFERENCES FILME(IDFILME)
);

INSERT INTO LOCACAO VALUES(1,'01/08/2019',23,3,100);
INSERT INTO LOCACAO VALUES(2,'01/02/2019',56,1,400);
INSERT INTO LOCACAO VALUES(3,'02/07/2019',23,3,400);
INSERT INTO LOCACAO VALUES(4,'02/02/2019',43,1,500);
INSERT INTO LOCACAO VALUES(5,'02/02/2019',23,2,100);
INSERT INTO LOCACAO VALUES(6,'03/07/2019',76,3,700);
INSERT INTO LOCACAO VALUES(7,'03/02/2019',45,1,700);
INSERT INTO LOCACAO VALUES(8,'04/08/2019',89,3,100);
INSERT INTO LOCACAO VALUES(9,'04/02/2019',23,3,800);
INSERT INTO LOCACAO VALUES(10,'05/07/2019',23,3,500);
INSERT INTO LOCACAO VALUES(11,'05/02/2019',38,3,800);
INSERT INTO LOCACAO VALUES(12,'01/10/2019',56,1,100);
INSERT INTO LOCACAO VALUES(13,'06/12/2019',23,3,400);
INSERT INTO LOCACAO VALUES(14,'01/02/2019',56,2,300);
INSERT INTO LOCACAO VALUES(15,'04/10/2019',76,3,300);
INSERT INTO LOCACAO VALUES(16,'01/09/2019',32,2,400);
INSERT INTO LOCACAO VALUES(17,'08/02/2019',89,3,100);
INSERT INTO LOCACAO VALUES(18,'01/02/2019',23,1,200);
INSERT INTO LOCACAO VALUES(19,'08/09/2019',45,3,300);
INSERT INTO LOCACAO VALUES(20,'01/12/2019',89,1,400);
INSERT INTO LOCACAO VALUES(21,'09/07/2019',23,3,1000);
INSERT INTO LOCACAO VALUES(22,'01/12/2019',21,3,1000);
INSERT INTO LOCACAO VALUES(23,'01/02/2019',34,2,100);
INSERT INTO LOCACAO VALUES(24,'09/08/2019',67,1,1000);
INSERT INTO LOCACAO VALUES(25,'01/02/2019',76,3,1000);
INSERT INTO LOCACAO VALUES(26,'01/02/2019',66,3,200);
INSERT INTO LOCACAO VALUES(27,'09/12/2019',90,1,400);
INSERT INTO LOCACAO VALUES(28,'03/02/2019',23,3,100);
INSERT INTO LOCACAO VALUES(29,'01/12/2019',65,5,1000);
INSERT INTO LOCACAO VALUES(30,'03/08/2019',43,1,1000);
INSERT INTO LOCACAO VALUES(31,'01/02/2019',27,31,200);


SELECT F.NOME, G.NOME, L.DATA, L.DIAS, L.MIDIA
FROM GENERO AS G
INNER JOIN FILME AS F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO AS L
ON F.IDFILME = L.ID_FILME
ORDER BY L.DIAS DESC;

/* É possível criar uma tabela com o resultado
   de uma querie e essa é a forma de realizar
   uma modelagem colunar
*/

CREATE TABLE RELATORIO_LOCADORA AS
SELECT F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO AS G
INNER JOIN FILME AS F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO AS L
ON F.IDFILME = L.ID_FILME
ORDER BY L.DIAS DESC;

SELECT * FROM RELATORIO_LOCADORA;

/* EXPORTANDO UM TABELA NO FORMATO CSV */
COPY RELATORIO_LOCADORA TO
-- determino para onde será copiado o arquivo
'/Users/luishenriquebelisario/Projetos/curso_sql/relatorio_locadora.csv'
-- digo qual o separador dos dados do arquivo
DELIMITER ','
-- digo que o arquivo tem sim cabeçalho
CSV HEADER;

/*
  Ao trabalhar com relatorios csv advindos de bancos de dados
  pode ocorrer de os relatorios ficarem desatualizados conforme
  forem sendo inseridos novos dados no banco. Para isso devemos
  utilizar procedimentos para sincronizar tais relatorios com
  os dados do banco de dados.
*/

DROP TABLE LOCACAO;

CREATE TABLE LOCACAO(
	IDLOCACAO INT PRIMARY KEY,
	DATA TIMESTAMP,
	MIDIA INT,
	DIAS INT,
	ID_FILME INT,
	FOREIGN KEY(ID_FILME)
	REFERENCES FILME(IDFILME)
);

CREATE SEQUENCE SEQ_LOCACAO;

/* A SEQUENCE É UM OBJETO DO POSTGRES QUE POSSUE
    UM VETOR DE NUMEROS. POSSO PEGAR ESSES NUMEROS
   PARA USAR COMO ID EM UMA OU MAIS TABELAS DO MEU BANCO.
   PARA USAR UM NUMERO DE UMA SEQUENCE USO: NEXTVAL('NOME_DA_SEQUENCE')
*/

INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/08/2018',23,3,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',56,1,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'02/07/2018',23,3,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'02/02/2018',43,1,500);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'02/02/2018',23,2,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'03/07/2018',76,3,700);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'03/02/2018',45,1,700);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'04/08/2018',89,3,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'04/02/2018',23,3,800);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'05/07/2018',23,3,500);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'05/02/2018',38,3,800);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/10/2018',56,1,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'06/12/2018',23,3,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',56,2,300);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'04/10/2018',76,3,300);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/09/2018',32,2,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'08/02/2018',89,3,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',23,1,200);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'08/09/2018',45,3,300);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/12/2018',89,1,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'09/07/2018',23,3,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/12/2018',21,3,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',34,2,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'09/08/2018',67,1,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',76,3,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',66,3,200);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'09/12/2018',90,1,400);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'03/02/2018',23,3,100);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/12/2018',65,5,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'03/08/2018',43,1,1000);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),'01/02/2018',27,31,200);

SELECT * FROM locadora.LOCACAO;

DROP TABLE RELATORIO_LOCADORA;

SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO AS G
INNER JOIN FILME AS F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO AS L
ON F.IDFILME = L.ID_FILME;


CREATE TABLE RELATORIO_LOCADORA AS
SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO AS G
INNER JOIN FILME AS F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO AS L
ON F.IDFILME = L.ID_FILME;

SELECT * FROM RELATORIO_LOCADORA;

/* SELECT PARA COMPARAR O ID MAXIMO DE RELATORIO E LOCACAO */
SELECT MAX(IDLOCACAO) AS RELATORIO, (SELECT MAX(IDLOCACAO) FROM locadora.LOCACAO) AS LOCACAO
FROM locadora.RELATORIO_LOCADORA;

/*
  Na query abaixo estou trazendo apenas os dados que estão no banco de dados
  das locações e não estão no relatorio da locadora. Repare que no WHERE
  estou filtrando apenas os dados que estão em IDLOCACAO do banco de dados
  mas nao estao no select do IDLOCACAO do RELATORIO_LOCADORA.
*/
SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO AS G
INNER JOIN FILME AS F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO AS L
ON F.IDFILME = L.ID_FILME
WHERE IDLOCACAO NOT IN (SELECT IDLOCACAO FROM locadora.RELATORIO_LOCADORA);

/* INSERINDO OS REGISTROS NOVOS NO RELATORIO */
INSERT INTO locadora.RELATORIO_LOCADORA
SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO AS G
INNER JOIN FILME AS F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO AS L
ON F.IDFILME = L.ID_FILME
WHERE IDLOCACAO NOT IN (SELECT IDLOCACAO FROM locadora.RELATORIO_LOCADORA);

/* AUTOMATIZANDO O PROCEDIMENTO ACIMA POR MEIO DE UMA TRIGGER
NO POSTGRES, PARA EXECUTAR UM TRIGGER, PRIMEIRO TENHO QUE
CRIAR A FUNÇÃO QUE A TRIGGER EXECUTARÁ. DEPOIS CRIO A TRIGGER
QUE CHAMARÁ A FUNÇÃO QUE CRIEI. OBS.: O $$ É O DELIMITADOR */

-- CRIANDO A FUNÇÃO
CREATE OR REPLACE FUNCTION ATUALIZA_RELATORIO()
RETURNS TRIGGER AS $$
BEGIN

INSERT INTO locadora.RELATORIO_LOCADORA
SELECT L.IDLOCACAO, F.NOME AS FILME, G.NOME AS GENERO, L.DATA AS DATA, L.DIAS AS DIAS, L.MIDIA AS MIDIA
FROM GENERO AS G
INNER JOIN FILME AS F
ON G.IDGENERO = F.ID_GENERO
INNER JOIN LOCACAO AS L
ON F.IDFILME = L.ID_FILME
WHERE IDLOCACAO NOT IN (SELECT IDLOCACAO FROM locadora.RELATORIO_LOCADORA);

COPY RELATORIO_LOCADORA TO
'/Users/luishenriquebelisario/Projetos/curso_sql/relatorio_locadora.csv'
DELIMITER ','
CSV HEADER;

RETURN NEW;
END;
$$
LANGUAGE PLPGSQL;

-- CRIANDO A TRIGGER
CREATE TRIGGER TG_RELATORIO
AFTER INSERT ON locadora.LOCACAO
FOR EACH ROW
    EXECUTE PROCEDURE ATUALIZA_RELATORIO();

-- PARA APGAR A TRIGGER USO O COMANDO ABAIXO:
DROP TRIGGER TG_RELATORIO ON locadora.LOCACAO;

-- INSERINDO NOVOS REGISTROS PARA TESTAR A TRIGGER
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),NOW(),100,7,300);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),NOW(),500,1,200);
INSERT INTO LOCACAO VALUES(NEXTVAL('SEQ_LOCACAO'),NOW(),800,6,500);

SELECT * FROM locadora.LOCACAO;
SELECT * FROM locadora.RELATORIO_LOCADORA;

-- ATUALIZANDO O CSV QND HÁ DELEÇÃO DE REGISTROS

-- DEFININDO DA FUNÇÃO
CREATE OR REPLACE FUNCTION DELETE_LOCACAO()
RETURNS TRIGGER AS
$$
BEGIN

    DELETE FROM locadora.RELATORIO_LOCADORA
    WHERE IDLOCACAO = OLD.IDLOCACAO;
    COPY RELATORIO_LOCADORA TO
    '/Users/luishenriquebelisario/Projetos/curso_sql/relatorio_locadora.csv'
    DELIMITER ','
    CSV HEADER;

    RETURN OLD;
END;
$$
LANGUAGE PLPGSQL;

-- CRIANDO A TRIGGER
CREATE TRIGGER DELETE_REG
    BEFORE DELETE ON locadora.LOCACAO
    FOR EACH ROW
    EXECUTE PROCEDURE DELETE_LOCACAO();

SELECT * FROM locadora.LOCACAO;
SELECT * FROM locadora.RELATORIO_LOCADORA;

DELETE FROM locadora.LOCACAO WHERE IDLOCACAO = 1;

/* Variaveis Dummy para Machine Learning */

set search_path to aulas;

/* Utilizando o Case */
SELECT NOME, SEXO FROM funcionarios;

SELECT NOME, CARGO,
CASE
    WHEN CARGO = 'Financial Advisor' THEN 'Condicao 01'
    WHEN CARGO = 'Structural Engineer' THEN 'Condicao 02'
    WHEN CARGO = 'Executive Secretary' THEN 'Condicao 03'
    WHEN CARGO = 'Sales Associative' THEN 'Condicao 04'
    ELSE 'OUTRAS CONDICOES'
END AS "CONDICOES"
FROM funcionarios;

SELECT NOME,
CASE
    WHEN SEXO = 'Masculino' THEN 'M'
    ELSE 'F'
END AS "SEXO"
FROM funcionarios;

/* UTILIZANDO VALORES BOOLEANOS */
SELECT NOME, CARGO, (SEXO = 'Masculino') AS Masculino, (SEXO = 'Feminino') AS Feminino
FROM funcionarios;

/* MESCLANDO AS TECNICAS */
SELECT NOME, CARGO,
CASE
    WHEN (SEXO = 'Masculino') = true THEN 1
    ELSE 0
END AS "MASCULINO",
CASE
    WHEN (SEXO = 'Feminino') = true THEN 1
    ELSE 0
END AS "FEMININO"
FROM funcionarios;

/* Filtros de Grupo */

-- Filtros baseados em valores numéricos
SELECT NOME, DEPARTAMENTO, SALARIO
FROM FUNCIONARIOS
WHERE SALARIO > 100000;

-- Filtros baseados em strings
-- Obs.: É case sensitive
SELECT NOME, DEPARTAMENTO, SALARIO
FROM funcionarios
WHERE DEPARTAMENTO = 'Ferramentas';

-- Filtros baseados em multiplos tipos e colunas
SELECT NOME, DEPARTAMENTO, SALARIO
FROM funcionarios
WHERE DEPARTAMENTO = 'Ferramentas' AND SALARIO > 100000;

-- Filtro baseado em unico tipo e coluna
SELECT NOME, DEPARTAMENTO, SALARIO
FROM funcionarios
WHERE DEPARTAMENTO = 'Ferramentas' OR DEPARTAMENTO = 'Books';

-- Filtro baseado em padrão de caracteres
SELECT DEPARTAMENTO, SUM(SALARIO) AS TOTAL
FROM FUNCIONARIOS
WHERE DEPARTAMENTO LIKE 'B%'
GROUP BY DEPARTAMENTO;

-- Filtro baseado em padrão de caracteres com mais letras
SELECT DEPARTAMENTO, SUM(SALARIO) AS TOTAL
FROM FUNCIONARIOS
WHERE DEPARTAMENTO LIKE 'Be%'
GROUP BY DEPARTAMENTO;

-- Utilizando o caracter coringa no meio da palavra
SELECT DEPARTAMENTO, SUM(SALARIO) AS TOTAL
FROM FUNCIONARIOS
WHERE DEPARTAMENTO LIKE 'B%s'
GROUP BY DEPARTAMENTO;

-- Filtrando apenas os departamentos com salario total maior que 400000
SELECT DEPARTAMENTO, SUM(SALARIO) AS TOTAL
FROM FUNCIONARIOS
GROUP BY DEPARTAMENTO
HAVING SUM(SALARIO) > 4000000;

/* Multiplos Contadores */
SELECT COUNT(*) FROM FUNCIONARIOS;

SELECT SEXO, COUNT(*)
FROM FUNCIONARIOS
WHERE SEXO = 'Masculino'
GROUP BY SEXO;

/* CONTANDO O NUMEROS DE FUNC E O NUMERO DE FUNC DO SEXO MASCULINO */
SELECT COUNT(*) AS QUANTIDADE_TOTAL,
(SELECT COUNT(*)
FROM FUNCIONARIOS
WHERE SEXO = 'Masculino'
GROUP BY SEXO) AS QTD_SEXO_MASCULINO
FROM FUNCIONARIOS;

/* CONTANDO O NUMEROS DE FUNC E O NUMERO DE FUNC DO SEXO FEMININO */
SELECT COUNT(*) AS QUANTIDADE_TOTAL,
(SELECT COUNT(*)
FROM FUNCIONARIOS
WHERE SEXO = 'Feminino'
GROUP BY SEXO) AS QTD_SEXO_FEMININO
FROM FUNCIONARIOS;

/* OUTRA FORMA DE FAZER AS QUERYS ACIMA, USANDO FILTER */
SELECT COUNT(*) AS QUANTIDADE_TOTAL,
COUNT(*) FILTER(WHERE SEXO = 'Masculino') AS QTD_SEXO_MASCULINO
FROM FUNCIONARIOS;

/* POSSO USAR O FILTER PARA VARIAS QUERYS MULTIPLAS */
SELECT COUNT(*) AS QUANTIDADE_TOTAL,
COUNT(*) FILTER(WHERE SEXO = 'Masculino') AS QTD_SEXO_MASCULINO,
COUNT(*) FILTER(WHERE DEPARTAMENTO = 'Books') AS QTD_DPT_BOOKS
FROM FUNCIONARIOS;

/* POSSO USAR COM VALORES NUMERICOS */
SELECT COUNT(*) AS QUANTIDADE_TOTAL,
COUNT(*) FILTER(WHERE SEXO = 'Masculino') AS "QTD_SEXO_MASCULINO",
COUNT(*) FILTER(WHERE DEPARTAMENTO = 'Books') AS "QTD_DPT_BOOKS",
COUNT(*) FILTER(WHERE SALARIO > 140000) AS "SALARIO > 140K"
FROM FUNCIONARIOS;

-- OBS.: O FILTER SÓ FUNCIONA COM O COUNT!

/* FORMATANDO STRINGS */

/* TRAZENDO APENAS OS DEPARTAMENTOS DISTINTOS USANDO DISTINCT */
SELECT DISTINCT DEPARTAMENTO FROM FUNCIONARIOS;

/* UPPERCASE */
SELECT DISTINCT UPPER(DEPARTAMENTO) FROM FUNCIONARIOS;

/* LOWERCASE */
SELECT DISTINCT LOWER(DEPARTAMENTO) FROM FUNCIONARIOS;

/* CONCATENANDO STRINGS/COLUNAS */
-- O || CONCATENA NO POSTGRES
SELECT CARGO || ' - ' || DEPARTAMENTO
FROM FUNCIONARIOS;

SELECT UPPER(CARGO || ' - ' || DEPARTAMENTO) AS "CARGO COMPLETO"
FROM FUNCIONARIOS;

/* REMOVENDO ESPAÇOS DE STRINGS */
SELECT LENGTH('    UNIDADOS    ');

/* APLICANDO TRIM PARA TIRAR OS ESPAÇOS */
SELECT TRIM('    UNIDADOS    ');

SELECT LENGTH(TRIM('    UNIDADOS    '));

SELECT * FROM FUNCIONARIOS;

/* CRIANDO COLUNA PARA DIZER SE O FUNC É OU NÃO ASSISTENTE */
SELECT NOME,
      CARGO || ' - ' || DEPARTAMENTO AS "CARGO COMPLETO",
      CASE
        WHEN CARGO || ' - ' || DEPARTAMENTO LIKE '%Assistant%' THEN 1
        ELSE 0
      END AS "ASSISTENTE"
FROM funcionarios;

