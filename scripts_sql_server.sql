USE EMPRESA
GO

CREATE TABLE FUNCIONARIO(
    /* NO SQL SERVER O IDENTITY = AUTO_INCREMENT */
    /* (1,1) SIGNIFICA QUE COMEÇA COM 1 E INCREMENTA DE 1 EM 1 */
    IDFUNCIONARIO INT PRIMARY KEY IDENTITY(1,1),
    NOME VARCHAR(50) NOT NULL,
    SEXO CHAR(1) NOT NULL,
    NASC DATE NOT NULL,
    EMAIL VARCHAR(30) UNIQUE
)
GO

/* CRIANDO CONSTRAINTS APÓS A CRIAÇÃO DA TABELA */
ALTER TABLE FUNCIONARIO
ADD CONSTRAINT CK_SEXO CHECK(SEXO IN('M', 'F'))
GO

/* ALTERANDO O NOME DE UMA COLUNA NO SQL SERVER */
SP_RENAME 'FUNCIONARIO.NASC', 'DATA_NASCIMENTO', 'COLUMN'
GO

/* CRIANDO UM RELACIONAMENTO 1 X 1 */
CREATE TABLE ENDERECO(
    IDENDERECO INT PRIMARY KEY IDENTITY(100, 10),
    BAIRRO VARCHAR(30),
    UF CHAR(2) NOT NULL,
    CHECK (UF IN('RJ', 'SP', 'MG')),
    ID_FUNCIONARIO INT UNIQUE
    /* O UNIQUE DEFINE QUE O RELACIONAMENTO SERÁ DE 1 PARA 1 */
)
GO

/* CRIANDO A FK */
ALTER TABLE ENDERECO
ADD CONSTRAINT FK_ENDERECO_FUNCIONARIO
FOREIGN KEY(ID_FUNCIONARIO) REFERENCES FUNCIONARIO(IDFUNCIONARIO)
GO

/* COMANDOS DE DESCRIÇÃO - SÃO FEITAS COM BASE EM PROCEDURES JÁ CRIADAS E ARMAZENADAS NO SISTEMA */
SP_COLUMNS FUNCIONARIO
GO

SP_HELP FUNCIONARIO
GO

/* INSERINDO DADOS */
INSERT INTO FUNCIONARIO VALUES('JOÃO', 'M', '1981-12-28', 'JOAO@GMAIL.COM')
INSERT INTO FUNCIONARIO VALUES('PAULO', 'M', '1978-09-23', 'PAULO@GMAIL.COM')
INSERT INTO FUNCIONARIO VALUES('MARCIA', 'F', '1998-10-05', 'MARCIA@GMAIL.COM')
INSERT INTO FUNCIONARIO VALUES('ANTONIO', 'M', '1987-11-20', 'ANTONIO@GMAIL.COM')
INSERT INTO FUNCIONARIO VALUES('RUI', 'M', '1999-07-25', 'RUI@GMAIL.COM')
GO

SELECT * FROM FUNCIONARIO
GO

INSERT INTO ENDERECO VALUES('FLAMENGO', 'RJ', 1)
INSERT INTO ENDERECO VALUES('FLAMENGO', 'RJ', 6)
INSERT INTO ENDERECO VALUES('FLAMENGO', 'RJ', 7)
INSERT INTO ENDERECO VALUES('FLAMENGO', 'RJ', 8)
INSERT INTO ENDERECO VALUES('FLAMENGO', 'RJ', 9)
GO

/* É UM RELACIONAMENTO 1 X N */
CREATE TABLE TELEFONE(
    IDTELEFONE INT PRIMARY KEY IDENTITY,
    TIPO CHAR(3) NOT NULL,
    NUMERO VARCHAR(20) NOT NULL,
    ID_ALUNO INT,
    CHECK (TIPO IN('RES', 'COM', 'CEL'))
)
GO

SP_RENAME 'TELEFONE.ID_ALUNO', 'ID_FUNCIONARIO', 'COLUMN'
GO

INSERT INTO TELEFONE VALUES('CEL', '98765-4567', 6)
INSERT INTO TELEFONE VALUES('RES', '98765-4567', 7)
INSERT INTO TELEFONE VALUES('COM', '98765-4567', 8)
INSERT INTO TELEFONE VALUES('CEL', '98765-4567', 9)
GO

SELECT * FROM FUNCIONARIO
GO

SELECT * FROM TELEFONE
GO

SELECT * FROM ENDERECO
GO

/* PEGAR A DATA ATUAL DO SISTEMA */
SELECT GETDATE()
GO

/* EVITA-SE CLAUSULAS AMBIGUAS COM PONTEIRAMENTO */
SELECT 
    F.NOME, 
    ISNULL(T.TIPO, 'SEM') AS 'TIPO', 
    ISNULL(T.NUMERO, 'NUMERO') AS TELEFONE, 
    E.BAIRRO, 
    E.UF
FROM FUNCIONARIO AS F LEFT JOIN TELEFONE AS T
ON F.IDFUNCIONARIO = T.ID_FUNCIONARIO
INNER JOIN ENDERECO AS E
ON F.IDFUNCIONARIO = E.ID_FUNCIONARIO
GO

/* TRABALHANDO COM DATAS */
SELECT NOME, DATA_NASCIMENTO
FROM FUNCIONARIO
GO

/* 
FUNÇÃO GETDATE() TRAZ DIA E HORA
DATEDIFF - CALCULA A DIFERENÇA ENTRE DUAS DATAS 
*/
SELECT NOME, GETDATE() AS DIA_HORA FROM FUNCIONARIO
GO

/* A FUNÇÃO MONTADA ABAIXO RETORNA, EM DIAS, O VALOR
DESDE A DATA DE NASCIMENTO DO FUNCIONARIO ATÉ A DATA DE HOJE
OBS.: O PRIMEIRO PARAMETRO REPRESENTA O INTERVALO DESEJADO
*/
SELECT NOME, DATEDIFF(DAY, DATA_NASCIMENTO, GETDATE()) AS IDADE_EM_DIAS
FROM FUNCIONARIO
GO

/* 
APÓS O RETORNO INTEIRO DO DATEDIFF() POSSO FAZER OPERAÇÕES MATEMATICAS 
NO CASO ABAIXO ESTOU TRANSFORMANDO OS DIAS EM ANOS
*/
SELECT NOME, (DATEDIFF(DAY, DATA_NASCIMENTO, GETDATE())/365) AS IDADE_EM_ANOS
FROM FUNCIONARIO
GO

/* TAMBEM POSSO ESPECIFICAR O INTERVALO EM MESES OU ANOS */
SELECT NOME, (DATEDIFF(MONTH, DATA_NASCIMENTO, GETDATE())/12) AS IDADE_EM_ANOS
FROM FUNCIONARIO
GO

SELECT NOME, DATEDIFF(YEAR, DATA_NASCIMENTO, GETDATE()) AS IDADE_EM_ANOS
FROM FUNCIONARIO
GO

/* DATENAME - TRAZ O NOME (STRING) DA PARTE DA DATA EM QUESTÃO */
SELECT NOME, DATENAME(MONTH, DATA_NASCIMENTO) AS MÊS
FROM FUNCIONARIO
GO

SELECT NOME, DATENAME(YEAR, DATA_NASCIMENTO) AS MÊS
FROM FUNCIONARIO
GO

/* POSSO TRAZER O DIA DA SEMANA EM QUE A PESSOA NASCEU */
SELECT NOME, DATENAME(WEEKDAY, DATA_NASCIMENTO) AS MÊS
FROM FUNCIONARIO
GO

/* DATEPART FAZ A MESMA COISA DO DATENAME PORÉM DEVOLVE UM NUMERO INTEIRO */
SELECT NOME, DATEPART(MONTH, DATA_NASCIMENTO) AS MÊS
FROM FUNCIONARIO
GO

/* POSSO MESCLAR FUNÇÕES */
SELECT NOME, DATEPART(MONTH, DATA_NASCIMENTO) AS MÊS_INT, DATENAME(MONTH, DATA_NASCIMENTO) AS MÊS_STR
FROM FUNCIONARIO
GO

/* DATEADD - RETORNA UMA DATA SOMANDO A OUTRA DATA 
ABAIXO ESTOU SOMANDO 365 À DATA DE HOJE
*/
SELECT DATEADD(DAY,365,GETDATE()) AS DAQUI_A_UM_ANO
GO

/* ABAIXO ESTOU ACRESCENTANDO 10 ANOS À DATA DE HOJE */
SELECT DATEADD(YEAR,10,GETDATE()) AS DAQUI_A_UM_ANO
GO

/* CONVERSÃO DE DADOS */
/* OPERADOR MATEMATICO 
NO CASO ABAIXO O SQL SERVER CONSEGUIU CONVERTER DE STR PARA INT AUTOMATICAMENTE
*/
SELECT 1 + '1'
GO

/* CONCATENADOR DE STRINGS */
SELECT '1' + '1'
GO

/* FUNCOES DE CONVERSAO DE DADOS */
SELECT CAST('1' AS INT) + CAST('1' AS INT)
GO

/* CONVERSÃO E CONCATENAÇÃO */
SELECT NOME,
CAST(DAY(DATA_NASCIMENTO) AS VARCHAR) + '/' +
CAST(MONTH(DATA_NASCIMENTO) AS VARCHAR) + '/' +
CAST(YEAR(DATA_NASCIMENTO) AS VARCHAR) AS DATA_NASCIMENTO
FROM FUNCIONARIO
GO

/* A FUNÇÃO CHARINDEX
RETORNA UM NUMERO INTEIRO QUE INDICA
A POSICAO DE UM DETERMINADO CARACETERE
NUM CONJUNTO DE DADOS.
O PRIMEIRO PARAMETRO INDICA O CHAR QUE ESTOU BUSCANDO
O SEGUNDO PARAMETRO INDICA ONDE ESTOU PROCURANDO
O TERCEIRO PARAMETRO INDICA DE ONDE VOU COMEÇAR A BUSCA
O TERCEIRO PARAMETRO É OPCIONAL.
QUANDO NÃO PASSO O TERCEIRO PARAMETRO
A CONTAGEM DEFAULT INICIA EM 1.
SE O CHAR NÃO FOR ENCONTRADO RETORNA 0.
*/
SELECT NOME, CHARINDEX('A', NOME) AS INDICE
FROM FUNCIONARIO
GO

SELECT NOME, CHARINDEX('A', NOME, 3) AS INDICE
FROM FUNCIONARIO
GO

/* A FUNÇÃO BULK INSERT AUXILIA NA IMPORTAÇÃO DE ARQUIVOS */
CREATE TABLE LANCAMENTO_CONTABIL(
    CONTA INT,
    VALOR INT,
    DEB_CRED CHAR(1)
)
GO

BULK INSERT LANCAMENTO_CONTABIL
FROM '/tmp//CONTAS.txt'
WITH
(
    FIRSTROW = 2,
    DATAFILETYPE = 'char',
    FIELDTERMINATOR = '\t',
    ROWTERMINATOR = '\n'
)
GO

SELECT * FROM LANCAMENTO_CONTABIL
GO

/* 
QUERY QUE TRAZENDO O NUMERO DA CONTA
E O SEU SALDO
*/

/* 
FAZENDO UMA FLAG DE DEBITO OU CREDITO 
A CONTA DO MULTIPLICADOR FAZ COM QUE DEBITO SEJA -1
E CREDITO SEJA 1
*/
SELECT CONTA, VALOR, DEB_CRED,
CHARINDEX('D', DEB_CRED) AS DEBITO,
CHARINDEX('C', DEB_CRED) AS CREDITO,
CHARINDEX('C', DEB_CRED) * 2 - 1 AS MULTIPLICADOR
FROM LANCAMENTO_CONTABIL
GO

/*
APLICO A CONTA DO VALOR DO SALDO * O MULTIPLICADOR
E AGRUPO POR CONTA
*/
SELECT CONTA,
SUM(VALOR * (CHARINDEX('C', DEB_CRED) * 2 - 1)) AS SALDO
FROM LANCAMENTO_CONTABIL
GROUP BY CONTA
GO

/* TRIGGERS */
CREATE TABLE PRODUTOS(
    IDPRODUTO INT IDENTITY PRIMARY KEY,
    NOME VARCHAR(50) NOT NULL,
    CATEGORIA VARCHAR (50) NOT NULL,
    PRECO NUMERIC(10,2) NOT NULL
    /* NUMERIC EQUIVALE AO FLOAT DO MYSQL */
)
GO

CREATE TABLE HISTORICO(
    IDOPERACAO INT IDENTITY PRIMARY KEY,
    PRODUTO VARCHAR(50) NOT NULL,
    CATEGORIA VARCHAR (50) NOT NULL,
    PRECOANTIGO NUMERIC(10,2) NOT NULL,
    PRECONOVO NUMERIC(10,2) NOT NULL,
    DATA DATETIME,
    USUARIO VARCHAR(50),
    MENSAGEM VARCHAR(100)
)
GO

INSERT INTO PRODUTOS VALUES('SQL SERVER DO BASICO AO AVANÇADO', 'LIVROS', 98.00)
INSERT INTO PRODUTOS VALUES('ORACLE ESSENCIAL', 'LIVROS', 50.00)
INSERT INTO PRODUTOS VALUES('LICENÇA POWERCENTER', 'SOFTWARES', 45000.00)
INSERT INTO PRODUTOS VALUES('NOTEBOOK I7', 'COMPUTADORES', 3150.00)
INSERT INTO PRODUTOS VALUES('DOMINE O POWER BI', 'LIVROS', 50.00)
GO

SELECT * FROM PRODUTOS
GO

SELECT * FROM HISTORICO
GO

/* VERIFICANDO O USUARIO DO BANCO */
SELECT SUSER_NAME()
GO


/* CRIANDO A TRIGGER - DATA MANIPULATION LANGUAGE */
CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE
AS
    DECLARE @IDPRODUTO INT
    DECLARE @PRODUTO VARCHAR(50)
    DECLARE @CATEGORIA VARCHAR(50)
    DECLARE @PRECOANTIGO NUMERIC(10,2)
    DECLARE @PRECONOVO NUMERIC(10,2)
    DECLARE @DATA DATETIME
    DECLARE @USUARIO VARCHAR(50)
    DECLARE @MENSAGEM VARCHAR(100)
    
    -- PRIMEIRO BLOCO
    -- VALORES VINDOS DE TABELAS SÃO INSERIDOS COM SELECT
    SELECT @IDPRODUTO = IDPRODUTO FROM inserted
    SELECT @PRODUTO = NOME FROM inserted
    SELECT @CATEGORIA = CATEGORIA FROM inserted
    SELECT @PRECOANTIGO = PRECO FROM deleted
    -- NO UPDATE O PRECO ANTIGO ESTÁ NO DELETED
    SELECT @PRECONOVO = PRECO FROM inserted
    
    -- SEGUNDO BLOCO
    -- VALORES VINDOS DE FUNÇÕES, OU LITERAIS SÃO INSERIDOS COM SET
    SET @DATA = GETDATE()
    SET @USUARIO = SUSER_SNAME()
    SET @MENSAGEM = 'VALOR INSERIDO PELA TRIGER TRG_ATUALIZA_PRECO'
    -- COLUNA MERAMENTE INFORMATIVA

    INSERT INTO HISTORICO
    (PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
    VALUES
    (@PRODUTO,@CATEGORIA,@PRECOANTIGO,@PRECONOVO,@DATA,@USUARIO,@MENSAGEM)

    PRINT 'TRIGGER EXECUTADA COM SUCESSO'
GO

-- EXECUTANDO UPDATE
UPDATE PRODUTOS SET PRECO = 100.00
WHERE IDPRODUTO = 1
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO
GO

UPDATE PRODUTOS SET NOME = 'C# ESSENCIAL'
WHERE IDPRODUTO = 1
GO

/* PROGRAMANDO TRIGGER PARA SER DISPARADA COM MUDANÇA EM APENAS UMA COLUNA, NO CASO, NA COLUNA PRECO */

DROP TRIGGER TRG_ATUALIZA_PRECO
GO

CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE AS
IF UPDATE(PRECO)
BEGIN
    DECLARE @IDPRODUTO INT
    DECLARE @PRODUTO VARCHAR(50)
    DECLARE @CATEGORIA VARCHAR(50)
    DECLARE @PRECOANTIGO NUMERIC(10,2)
    DECLARE @PRECONOVO NUMERIC(10,2)
    DECLARE @DATA DATETIME
    DECLARE @USUARIO VARCHAR(50)
    DECLARE @MENSAGEM VARCHAR(100)
    
    -- PRIMEIRO BLOCO
    -- VALORES VINDOS DE TABELAS SÃO INSERIDOS COM SELECT
    SELECT @IDPRODUTO = IDPRODUTO FROM inserted
    SELECT @PRODUTO = NOME FROM inserted
    SELECT @CATEGORIA = CATEGORIA FROM inserted
    SELECT @PRECOANTIGO = PRECO FROM deleted
    -- NO UPDATE O PRECO ANTIGO ESTÁ NO DELETED
    SELECT @PRECONOVO = PRECO FROM inserted
    
    -- SEGUNDO BLOCO
    -- VALORES VINDOS DE FUNÇÕES, OU LITERAIS SÃO INSERIDOS COM SET
    SET @DATA = GETDATE()
    SET @USUARIO = SUSER_SNAME()
    SET @MENSAGEM = 'VALOR INSERIDO PELA TRIGER TRG_ATUALIZA_PRECO'
    -- COLUNA MERAMENTE INFORMATIVA

    INSERT INTO HISTORICO
    (PRODUTO,CATEGORIA,PRECOANTIGO,PRECONOVO,DATA,USUARIO,MENSAGEM)
    VALUES
    (@PRODUTO,@CATEGORIA,@PRECOANTIGO,@PRECONOVO,@DATA,@USUARIO,@MENSAGEM)

    PRINT 'TRIGGER EXECUTADA COM SUCESSO'
END
GO

UPDATE PRODUTOS SET PRECO = 300.00
WHERE IDPRODUTO = 2
GO

SELECT * FROM HISTORICO
GO

UPDATE PRODUTOS SET NOME = 'JAVA ESSENCIAL'
WHERE IDPRODUTO = 2
GO

/* CRIANDO VARIAVEL COM SELECT */

CREATE TABLE RESULTADO(
    IDRESULTADO INT PRIMARY KEY IDENTITY,
    RESULTADO INT
)
GO

INSERT INTO RESULTADO VALUES((SELECT 10+10))
GO

SELECT * FROM RESULTADO

/* ATRIBUINDO SELECTS A VARIAVEIS - BLOCO ANONIMO */
DECLARE
    @RESULTADO INT
    SET @RESULTADO = (SELECT 50+10)
    INSERT INTO RESULTADO VALUES(@RESULTADO)
    GO

DECLARE
    @RESULTADO INT
    SET @RESULTADO = (SELECT 50+50)
    INSERT INTO RESULTADO VALUES(@RESULTADO)
    PRINT 'VALOR INSERIDO NA TABELA: ' + CAST(@RESULTADO AS VARCHAR)
    GO

/* TRIGGER UPDATE */
CREATE TABLE EMPREGADO(
    IDEMPREGADO INT PRIMARY KEY,
    NOME VARCHAR(30),
    SALARIO MONEY,
    -- O MONEY JA VEM COM DUAS CASAS APÓS O PONTO POR PADRÃO
    IDGERENTE INT
)
GO

ALTER TABLE EMPREGADO ADD CONSTRAINT FK_GERENTE
FOREIGN KEY(IDGERENTE) REFERENCES EMPREGADO(IDEMPREGADO)
GO

INSERT INTO EMPREGADO VALUES(1, 'CLARA', 5000.00, NULL)
INSERT INTO EMPREGADO VALUES(2, 'CELIA', 4000.00, 1)
INSERT INTO EMPREGADO VALUES(3, 'JOAO', 3000.00, 1)
GO

CREATE TABLE HIST_SALARIO(
    IDEMPREGADO INT,
    ANTIGO_SALARIO MONEY,
    NOVO_SALARIO MONEY,
    [DATA] DATETIME
)
GO

CREATE TRIGGER TG_SALARIO
ON DBO.EMPREGADO
FOR UPDATE AS
IF UPDATE(SALARIO)
BEGIN
    INSERT INTO HIST_SALARIO
    (IDEMPREGADO,ANTIGO_SALARIO,NOVO_SALARIO,[DATA])
    SELECT D.IDEMPREGADO, D.SALARIO,I.SALARIO,GETDATE()
    FROM DELETED D, INSERTED I
    WHERE D.IDEMPREGADO = I.IDEMPREGADO
END
GO

SELECT * FROM EMPREGADO

UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1
GO

/* SALARIO ANTIGO, NOVO, DATA E NOME DO EMPREGO */

CREATE TABLE SALARIO_RANGE(
    MINSAL MONEY,
    MAXSAL MONEY
)
GO

INSERT INTO SALARIO_RANGE VALUES(3000.00,6000.00)
GO

CREATE TRIGGER TG_RANGE
ON DBO.EMPREGADO
FOR INSERT, UPDATE
AS
    DECLARE
        @MINSAL MONEY,
        @MAXSAL MONEY,
        @ATUALSAL MONEY
    
    SELECT @MINSAL = MINSAL, @MAXSAL = MAXSAL FROM SALARIO_RANGE

    SELECT @ATUALSAL = I.SALARIO
    FROM INSERTED AS I

    IF(@ATUALSAL < @MINSAL)
        BEGIN
            RAISERROR('SALÁRIO MENOR QUE O PISO',16,1)
            -- A FUNÇÃO RAISERROR CARREGA UM ERRO NA QUERY
            -- O 16,1 É A CATEGORIA DO ERRO, NESSE CASO É UM ERRO DO USUARIO
            ROLLBACK TRANSACTION
            -- O ROLLBACK TRANSACTION DESFAZ A TRANSAÇÃO QUE FOI FEITA ANTERIORMENTE
        END

    IF(@ATUALSAL > @MAXSAL)
        BEGIN
            RAISERROR('SALÁRIO MAIOR QUE O PISO',16,1)
            ROLLBACK TRANSACTION
        END
GO

SELECT * FROM EMPREGADO

UPDATE EMPREGADO SET SALARIO = 9000.00
WHERE IDEMPREGADO = 1
GO

UPDATE EMPREGADO SET SALARIO = 1000.00
WHERE IDEMPREGADO = 1
GO

/* NOS DOIS CASOS ACIMA AS TRANSAÇÕES NÃO SERÃO FINALIZADAS 
POIS DESOBEDECEM À LEI ESTIPULADA NA TRIGGER */

SP_HELPTEXT TG_RANGE
GO

DROP TABLE TELEFONE
GO

/* PROCEDURES */

--SP_ STORAGE PROCEDURE

CREATE TABLE PESSOA(
	IDPESSOA INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30) NOT NULL,
	SEXO CHAR(1) NOT NULL CHECK (SEXO IN('M','F')), --ENUM
	MASCIMENTO DATE NOT NULL
)
GO

CREATE TABLE TELEFONE(
	IDTELEFONE INT NOT NULL IDENTITY,
	TIPO CHAR(3) NOT NULL CHECK ( TIPO IN('CEL','COM')),
	NUMERO CHAR(10) NOT NULL,
	ID_PESSOA INT
)
GO

ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE_PESSOA
FOREIGN KEY(ID_PESSOA) REFERENCES PESSOA(IDPESSOA)
ON DELETE CASCADE
GO

INSERT INTO PESSOA VALUES('ANTONIO','M','1981-02-13')
INSERT INTO PESSOA VALUES('DANIEL','M','1985-03-18')
INSERT INTO PESSOA VALUES('CLEIDE','F','1979-10-13')
INSERT INTO PESSOA VALUES('MAFRA','M','1981-02-13')

SELECT @@IDENTITY -- GUARDA O ULTIMO IDENTITY INSERIDO NA SECAO
GO

SELECT * FROM PESSOA

INSERT INTO TELEFONE VALUES('CEL','9879008',1)
INSERT INTO TELEFONE VALUES('COM','8757909',1)
INSERT INTO TELEFONE VALUES('CEL','9875890',2)
INSERT INTO TELEFONE VALUES('CEL','9347689',2)
INSERT INTO TELEFONE VALUES('COM','2998689',3)
INSERT INTO TELEFONE VALUES('COM','2098978',2)
INSERT INTO TELEFONE VALUES('CEL','9008679',3)
GO

/* CRIANDO A PROCEDURE */

CREATE PROC SOMA
AS
    SELECT 10 + 10 AS SOMA
GO

/* EXECUTANDO A PROCEDURE */
EXEC SOMA
GO

/* PROCEDURES DINAMICAS - COM PARAMETROS */
CREATE PROC CONTA @NUM1 INT, @NUM2 INT
AS
    SELECT @NUM1 + @NUM2
GO

EXEC CONTA 90,100
GO

/* APAGANDO PROCEDURES */
DROP PROC CONTA
GO

CREATE PROC CONTA @NUM1 INT, @NUM2 INT
AS
    SELECT @NUM1 + @NUM2 AS RESULTADO
GO

EXEC CONTA 90,100
GO

/* PROCEDURES EM TABELAS */
SELECT NOME, NUMERO
FROM PESSOA
INNER JOIN TELEFONE
ON IDPESSOA = ID_PESSOA
WHERE TIPO = 'CEL'
GO

/* TRAZER OS TELEFONES DE ACORDO COM O TIPO PASSADO POR PARAMETRO */
CREATE PROC EXIBIR_TELEFONE @TIPO CHAR(3)
AS
    SELECT NOME, NUMERO
    FROM PESSOA
    INNER JOIN TELEFONE
    ON IDPESSOA = ID_PESSOA
    WHERE TIPO = @TIPO
GO

EXEC EXIBIR_TELEFONE 'CEL'
GO

EXEC EXIBIR_TELEFONE 'RES'
GO

EXEC EXIBIR_TELEFONE 'COM'
GO

/* PARAMETROS DE OUTPUT (SAIDA) */
SELECT TIPO, COUNT(*) AS QUANTIDADE
FROM TELEFONE
GROUP BY TIPO
GO

-- OUTPUT INDICA QUE AQUELE PARAMETRO É DE SAÍDA
CREATE PROCEDURE GETTIPO @TIPO CHAR(3), @CONTADOR INT OUTPUT
AS
    SELECT @CONTADOR = COUNT(*)
    FROM TELEFONE
    WHERE TIPO = @TIPO
GO

/* OBS.: TSQL - TRANSACTION SQL -> LINGUAGEM DO SQL SERVER */
/* PARA MANIPULAR UM PARAMETRO DE SAIDA TENHO QUE RECEBE-LO NUMA VARIAVEL */
DECLARE @SAIDA INT
EXEC GETTIPO @TIPO = 'COM', @CONTADOR = @SAIDA OUTPUT
SELECT @SAIDA AS QUANTIDADE_TIPO
GO

/* CRIANDO PROCEDURES COMO REGRA DE NEGOCIO */
CREATE PROC CADASTRO @NOME VARCHAR(30), @SEXO CHAR(1), @NASCIMENTO DATE,
@TIPO CHAR(3), @NUMERO VARCHAR(10)
AS
    DECLARE @FK INT

    INSERT INTO PESSOA VALUES(@NOME, @SEXO, @NASCIMENTO) -- COMO INSERI UMA PESSOA ACABEI DE GERAR UM ID

    SET @FK = (SELECT IDPESSOA FROM PESSOA WHERE IDPESSOA = @@IDENTITY)

    INSERT INTO TELEFONE VALUES (@TIPO, @NUMERO, @FK)
GO

CADASTRO 'RONALDO', 'M', '1981-03-04', 'CEL', '9191876'
GO

SELECT PESSOA.*, TELEFONE.*
FROM PESSOA INNER JOIN TELEFONE
ON IDPESSOA = ID_PESSOA
GO

/* TSQL É UM BLOCO DE LINGUAGEM DE PROGRAMAÇÃO 
PROGRAMAS SÃO UNIDADES QUE PODEM SER CHAMADAS DE BLOCOS ANÔNIMOS.
BLOCOS ANÔNIMOS NÃO RECEBEM NOME POIS NÃO SÃO SALVOS NO BANCO.
CRIAMOS BLOCOS ANÔNIMOS QUANDO IREMOS EXECUTÁ-LOS UMA SÓ VEZ
OU TESTAR ALGO. EXISTEM VÁRIOS TIPOS DE BLOCOS:
*/

-- BLOCOS DE EXECUÇÃO
BEGIN
    PRINT 'PRIMEIRO BLOCO'
END
GO

-- BLOCOS DE ATRIBUIÇÃO DE VARIÁVEIS
DECLARE
    @CONTADOR INT
BEGIN
    SET @CONTADOR = 5
    PRINT @CONTADOR
END
GO

/* CONCATENAÇÃO */
DECLARE
    @V_NUMERO NUMERIC(10,2) = 100.52,
    @V_DATA DATETIME = '20170207'
BEGIN
    PRINT 'VALOR NUMÉRICO: ' + CAST(@V_NUMERO AS VARCHAR)
    PRINT 'VALOR NUMÉRICO: ' + CONVERT(VARCHAR, @V_NUMERO)
    -- CAST E CONVERT FAZEM A MESMA COISA
    -- MAS O CONVERT É MAIS USADO EM DATAS
    PRINT 'VALOR DE DATA: ' + CONVERT(VARCHAR, @V_DATA, 121)
    PRINT 'VALOR DE DATA: ' + CONVERT(VARCHAR, @V_DATA, 120)
    PRINT 'VALOR DE DATA: ' + CONVERT(VARCHAR, @V_DATA, 105) -- FORMATO PT-BR
    -- MAS POSSO USAR O CAST COM DATAS TAMBÉM
    PRINT 'VALOR DE DATA: ' + CAST(@V_DATA AS VARCHAR)
    -- EM TODOS OS CASOS ACIMA ESTOU CONVERTENDO AS VARIÁVEIS PARA VARCHAR
END
GO

/* ATRIBUINDO RESULTADOS A VARIAVEIS */
CREATE TABLE CARROS(
	CARRO VARCHAR(20),
	FABRICANTE VARCHAR(30)
)
GO

INSERT INTO CARROS VALUES('KA','FORD')
INSERT INTO CARROS VALUES('FIESTA','FORD')
INSERT INTO CARROS VALUES('PRISMA','FORD')
INSERT INTO CARROS VALUES('CLIO','RENAULT')
INSERT INTO CARROS VALUES('SANDERO','RENAULT')
INSERT INTO CARROS VALUES('CHEVETE','CHEVROLET')
INSERT INTO CARROS VALUES('OMEGA','CHEVROLET')
INSERT INTO CARROS VALUES('PALIO','FIAT')
INSERT INTO CARROS VALUES('DOBLO','FIAT')
INSERT INTO CARROS VALUES('UNO','FIAT')
INSERT INTO CARROS VALUES('GOL','VOLKSWAGEN')
GO

DECLARE
    @V_CONT_FORD INT, 
    @V_CONT_FIAT INT
BEGIN
    -- METODO 1 - O SELECT PRECISA RETORNAR UMA SIMPLES COLUNA E UM SÓ RESULTADO
    SET @V_CONT_FORD = (SELECT COUNT(*) FROM CARROS 
    WHERE FABRICANTE = 'FORD')
    PRINT 'QUANTIDADE FORD: ' + CAST(@V_CONT_FORD AS VARCHAR)

    -- METODO 2 - A VARIÁVEL RECEBE O RESULTADO DO COUNT() E DEPOIS É PROJETADA
    SELECT @V_CONT_FIAT = COUNT(*) FROM CARROS WHERE FABRICANTE = 'FIAT'
    PRINT 'QUANTIDADE FIAT: ' + CAST(@V_CONT_FIAT AS VARCHAR)
END
GO

/* BLOCOS IF E ELSE */
DECLARE
    @NUMERO INT = 5
BEGIN
    IF @NUMERO = 5 -- EXPRESSÃO BOOLEANA
        PRINT 'VERDADEIRO'
    ELSE
        PRINT 'FALSO'
END
GO

/* CASE */
DECLARE
    @CONT INT
BEGIN
    -- O CASE REPRESENTA UMA COLUNA
    SELECT
    CASE
        WHEN FABRICANTE = 'FIAT' THEN 'FAIXA 1'
        WHEN FABRICANTE = 'CHEVROLET' THEN 'FAIXA 2'
        ELSE 'OUTRA FAIXAS'
    END AS 'INFORMAÇÕES', -- O END TAMBEM REPRESENTA UMA COLUNA
    *
    FROM CARROS
END
GO

/* BLOCOS NOMEADOS */
CREATE PROC VALIDA_NUM @NUM1 INT, @NUM2 INT
AS
    IF @NUM1 > @NUM2
        PRINT 'NUM1 É MAIOR'
    IF @NUM2 > @NUM1
        PRINT 'NUM2 É MAIOR'
    IF @NUM1 = @NUM2
        PRINT 'IGUAIS'
GO

DROP PROC VALIDA_NUM
GO

EXEC VALIDA_NUM 10,5
GO

EXEC VALIDA_NUM 5,10
GO

EXEC VALIDA_NUM 5,5
GO

/* LOOPS WHILE */
DECLARE
    @I INT = 1
BEGIN
    WHILE (@I < 15)
    BEGIN
        PRINT 'VALOR DE @I: ' + CAST(@I AS VARCHAR)
        SET @I = @I + 1
    END
END
GO
